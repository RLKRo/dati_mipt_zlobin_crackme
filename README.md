# dati_mipt_zlobin_crackme

# 13.   CrackMe. Зверская) задача

Вам дана программа crackme [http://tiny.cc/s304nz] (измените расширение файла на .exe), которая ожидает от вас логин и пароль. Патчить программу нельзя. Напишите keygen - консольное или оконное/графическое решение, которая принимает на вход логин (проверяет валидный ли логин) и возвращает минимум один пароль, подходящие для crackme. Оцениваться будет не только решение, но и стиль кода, его архитектура.

# Решение

Дизассемблируем программу. Изначально это было сделано с помощью radare2:
```
$ radare2 ~/Downloads/crackme.exe
[0x00401000]> pd $s | less >> crackme.asm
```
Результат выполнения находится в 'crackme.asm'. Секция Code находится в 'crackme_code.asm'.

На 243 строке на 0x0040134d offset начинается функция, выводящая требуемое сообщение "Good work!". Посмотрим, где вызывается 'call 0x40134d'. Это происходит на 166 строке на 0x0040124c offset. В это место можно попасть из инструкции 'je 0x40124c' на 0x00401243 offset, которая производит прыжок, если значения регистров eax и ebx совпадают ('cmp eax, ebx').

На этом месте анализировать код из этого файла стало сложнее, поэтому далее используется IDA Pro.

![crackme_1](https://user-images.githubusercontent.com/61429541/118042698-10425a80-b37d-11eb-90a2-d7fa97c59c7e.png)

Сначала вызывается функция по адресу 0x40137E, которая обрабатывает строку String, записывает результат в eax. Он сохраняется на стеке, и вызывается функция по адресу 0x4013D8, обрабатывающая строку byte_40217E. Она записывает результат в ebx, eax поднимается со стека, их значения сравниваются.

На смещении 0x401253 функция, реализующая считывание вводимых в окно данных.

![crackme_2](https://user-images.githubusercontent.com/61429541/118042716-16d0d200-b37d-11eb-88e4-c401a7a64925.png)

Функция GetDlgItemTextA возвращает количество считанных символов, не считая '\0'. Поэтому прыжок после 'cmp eax, 1' происходит тогда, когда eax < 1, т.е. функция вернула 0 символов. Для считывания byte_40217E такого ограничения нет.

Попробуем ввести пустой логин и пустой ключ. При пустом логине диалоговое окно сбрасывается, что соответсвует вызову 'jmp     short loc_4012F7'. При вводе пустого ключа выводится окно о том, что введен неправильный ключ. Поэтому в String хранится логин, в byte_40217E -- ключ.

Для обработки логина вызывается следующая функция:

![crackme_3](https://user-images.githubusercontent.com/61429541/118042736-1cc6b300-b37d-11eb-9418-29314fa54b49.png)

В ней вызываются следующие функции:

![crackme_4](https://user-images.githubusercontent.com/61429541/118042750-218b6700-b37d-11eb-82e0-1866d9d1c75b.png)

До этого на стек был положен оффсет String, поэтому в esi хранится адрес строки. Далее в al помещается значение по этому адресу. Если оно не равно нулю, то происходит его обработка. Если оно меньше 'A', то выводится сообщение об ошибке. Если оно больше 'Z', то из него вычитается '20h'. Если символ был строчной буквой, то при таком вычитании он перейдет в заглавную. После этого значение esi увеличивается --- происходит переход к следующему символу.

После этого вызывается функция sub_4013C2, которая складывает все символы. К результату применяется xor 5678h. Это возвращается через eax регистр.


Для обработки пароля вызывается следующая функция:

![crackme_5](https://user-images.githubusercontent.com/61429541/118043738-7085cc00-b37e-11eb-8b34-3b7b2a5d47b7.png)

Она вычитает из каждого симовла '0', умножает текущий результат на 10 (в eax хранится '0Ah'), прибавляет значение символа за вычетом '0' к результату. Если в качестве ключа используется число, то она переводит его из строкового представления в машинное.

После этого к результату применяется xor 1234h. Этот результат возвращается в ebx регистр. 

После этого результаты сравниваются.

Так как обратная операция к xor есть сам xor, то алгоритм нахождения ключа следующий:
1. Обрабатываем логин
2. Применяем xor 1234h
